Start Time,End Time,Text
0.0,19.080000000000002,"Let's get started, everybody."
19.080000000000002,26.68,"So last lecture we began talking about this topic of recursion, and hopefully solidified"
26.68,32.56,a few sort of really fundamental ideas about recursion that we're going to use in today's
32.56,33.56,lecture.
33.56,40.88,"Today's lecture, the first half of it is we're going to talk about recursion just kind of"
40.88,46.08,"to review on some actual numerical examples, but then the second half, which is the main"
46.08,49.36,"event for today, is going to be recursion on non-numeric."
49.36,54.6,"So specifically recursion on lists, but the techniques we'll see on lists can be applied to"
54.6,60.0,"other things that are non-numeric as well, like two pulls or strings or things like that."
60.0,64.84,So let's start the review of a little bit of review of what we talked about last time
64.84,67.44,in some of the big ideas by looking at this example.
67.44,71.92,So we're going to write a recursive function for the Fibonacci sequence.
71.92,77.92,"And the Fibonacci sequence exists in nature and a lot of places, one specific place is"
77.92,84.8,you can model a mating of rabbits using Fibonacci sequence.
84.8,86.52,But we won't be setting that in depth today.
86.52,88.68,We're just going to be looking at the sequence itself.
88.68,95.64,"So just to remind you, the idea behind Fibonacci is we start out with two sort of basic values."
95.64,99.0,"Fibonacci of one is one, and Fibonacci of two is one."
99.0,102.6,"So in my table here, I've got these two starting values."
102.6,107.44,And we can fill in the remainder of the table by basically saying Fibonacci of n is Fibonacci
107.44,110.64,of n minus 1 plus Fibonacci of n minus 2.
110.64,113.0,So Fibonacci of three will be 1 plus 1.
113.0,115.16,Fibonacci of four will be 2 plus 1.
115.16,116.96,Fibonacci of five is 3 plus 2.
116.96,119.03999999999999,Fibonacci of six is 5 plus 3.
119.03999999999999,121.24,And Fibonacci of seven is 8 plus 5.
121.24,125.44,That's the sequence we all know and love.
125.44,131.0,"So our two base cases, if we're going to put this in mathematical terms, are Fibonacci of"
131.0,131.64,one is one.
131.64,133.92,Fibonacci of two is one.
133.92000000000002,141.08,"And our recursive step, in terms of the math and slash programming, Lingo is going to"
141.08,147.08,be the Fibonacci of n is equal to Fibonacci of n minus 1 plus Fibonacci of n minus 2.
147.08,152.88000000000002,"So we put that in our function, so we slap a definition around that code and turn it"
152.88000000000002,155.4,into a nice function that we can run.
155.4,158.76000000000002,"If x is 1 or x is 2, those are our two base cases."
158.76000000000002,163.48000000000002,"We just return 1 right off the bat, nothing to call, no functions to call."
163.48,169.2,"There are base cases, but otherwise we're going to return a value and the thing we're"
169.2,174.82,"going to return is a call to Fibonacci of n minus 1 plus Fibonacci of n minus 2, just"
174.82,179.23999999999998,like the mathematical definition said to do.
179.23999999999998,183.28,"So this is different than what we saw last lecture, last lecture, and our recursive step,"
183.28,186.95999999999998,"we had basically just one function called to ourselves, right?"
186.95999999999998,192.23999999999998,"So whatever function we had to find up here, we only had return, you know, some variation"
192.24,196.48000000000002,"of that function down here with something else tacked onto it, like an addition of"
196.48000000000002,198.56,some value or something else.
198.56,203.4,"In this case, we actually have the function being called twice, okay?"
203.4,209.4,So we're going to see what implications this has as we trace through the code.
209.4,213.68,"And so as I trace through the code, I'll remind you of some of the big ideas that we learned"
213.68,216.08,last lecture.
216.08,219.88,So let's say that we wanted to calculate Fibonacci of 6.
219.88,225.64,"And so I'm going to illustrate a function call just by, you know, the name of the function"
225.64,228.2,with the parameter that I'm calling.
228.2,233.4,So one of the big ideas from last lecture was that when you make a function call that to
233.4,238.48,"a function that's recursive, you're going to trace through that function call and the"
238.48,241.56,environment for that function just as you normally would.
241.56,246.64,"But as soon as you see another function call, so in this case, Fibonacci of 6 doesn't enter"
246.72000000000003,250.8,"the base cases, it goes up into the recursive step."
250.8,257.08000000000004,"And it says, I'm going to calculate Fibonacci of x minus 1 plus Fibonacci of x minus 2."
257.08000000000004,263.08000000000004,"So for this Fibonacci of 6 function call, let's follow along and say, well, Fibonacci"
263.08000000000004,269.96000000000004,"of 6 will say, I want to calculate Fibonacci of 5."
269.96000000000004,275.96000000000004,"Is it, this is my question to you, is it going to now calculate Fibonacci of 4?"
277.64,280.64,"No, very good."
280.64,287.64,"Because Fibonacci of 5 is a function call, right, we need to explore what this function will"
287.64,294.64,"return before Fibonacci of 6 can add the result of this, the return of this to Fibonacci of 4."
294.64,303.64,So that means that this new Fib 5 is an entirely new environment calling Fibonacci with n is equal to 5.
303.64,307.64,Completely separate than our original Fibonacci of 6 call.
307.64,310.64,So let's explore what Fibonacci of 5 is going to do.
310.64,313.64,"Well, in its function call, it's going to again go in the recursive step."
313.64,316.64,It's going to figure out Fibonacci of 4.
316.64,321.64,"And then it's going to pause there, right, because it needs to figure out what Fibonacci of 4 is before it finishes its"
321.64,324.64,"other half, right, to do Fibonacci of 3."
324.64,330.64,"So Fibonacci of 4 will now create a new environment, and now it has to explore its return."
330.64,337.64,So Fibonacci of 4 is again going into the recursive step to calculate Fibonacci of 3 plus something.
337.64,342.64,"But we don't know what that something is yet, because we have to explore what Fibonacci of 3 is, right?"
342.64,349.64,"So already where 4 function calls deep and we haven't really done any work that we can see the result of, right?"
349.64,351.64,There's no values being passed back.
351.64,359.64,All we're doing is exploring this path down until we get to some sort of base case that will kick off our
359.64,363.64,sort of conquer step where we pass values back up the chain.
363.64,372.64,"So Fibonacci of 3 again is going to look at Fibonacci of 2, and finally we've reached a base case."
372.64,377.64,"So Fibonacci of 2 will immediately return, right? It doesn't make another function call."
377.64,387.64,"So Fibonacci of 2 will return a value, and then Fibonacci of 3 in its function call has the result for Fibonacci of 2."
387.64,392.64,"And then it's going to do plus that value plus Fibonacci of 1, right?"
392.64,394.64,3 minus 2. So that's this one here.
394.64,402.64,"It can easily grab the, do that addition and return the value back up to Fibonacci of 3."
402.64,409.64,"So now Fibonacci of 3 has its first half ready, right?"
409.64,415.64,"So Fibonacci of 4, sorry, so Fibonacci of 4 has its first half ready, Fibonacci of 3."
415.64,421.64,"So Fibonacci of 4 was trying to figure out what Fib 3 was, and it did, right?"
421.64,426.64,"It was Fib 2 plus Fib 1, 2. So now it has a value for its first half here,"
426.64,432.64,"and it needs to add that value to Fibonacci of 2, 4 minus 2."
432.64,435.64,"So it will explore that path, that's a base case."
435.64,441.64,"So all it does is return the value immediately, and now Fibonacci of 4 has its value,"
441.64,446.64,"whatever Fib 3 was, that we figured out, plus Fib 2."
446.64,451.64,"Now Fib 4, we have a value for it when we called Fib 5."
451.64,456.64,"So Fib 5 is now halfway happy because it knows what Fib 4 is,"
456.64,460.64,but it needs to add that to Fib 3.
460.64,465.64,"So Fib 5 is still halted, right? It can't return anything,"
465.64,468.64,but because now it needs to explore what Fib 3 is.
468.64,475.64,"Well, Fib 3 is going to be,"
475.64,480.64,"do another function call, right? So it's going to call Fib 2 and Fib 1,"
480.64,484.64,"which are two base cases, which easily return the value back up to Fib 3."
484.64,489.64,"And now Fib 5 is happy because it knows this value, and now it knows this value,"
489.64,494.64,"it can add them together, and Fib 5 now has a value that it can keep track of."
494.64,498.64,"And now finally, Fib 6, we're not even close to being done."
498.64,504.64,"Fib 6 has a Fib 5 value, so it has half of the things it needs to figure out what Fib 6 is,"
504.64,507.64,because now it has to figure out what Fib 4 is.
507.64,510.64,And already you can tell what we're going to do next.
510.64,513.64,We're going to start exploring the exact same way like we did before.
513.64,515.64,Fib 4 needs to calculate Fib 3.
515.64,520.64,"It can't do Fib 2 yet because Fib 3 needs to calculate Fib 2 and Fib 1, right?"
520.64,526.64,"Pass back up the value, Fib 4 can now finish its job by calculating Fib 3 and Fib 2,"
526.64,532.64,"pass up the value, and now finally Fib 6 has its two halves here, Fib 5 and Fib 4,"
532.64,536.64,"and it can add them together and return the value, okay?"
536.64,544.64,"So a super inefficient algorithm because there's a lot of sort of stuff going on,"
544.64,547.64,"but not much work being done until the end, right?"
547.64,552.64,We've got a bunch of base cases we get to and then we can start building back up our result.
552.64,557.64,"And the reason why I say it's inefficient is because, well, we're exploring these paths"
557.64,564.64,"and as we go along the way, right, we figure out what Fib 3 is and what Fib 4 is, right?"
564.64,573.64,"But then when we explore the right half of Fib 6 over here, we're actually recalculating these values all over again."
573.64,579.64,"That's why I said we're not even halfway done because when we got Fib 5, we had to explore Fib 4"
579.64,585.64,"and Fib 4, this branch down here is basically a copy of this one down here, okay?"
585.64,591.64,So there's a lot of work being done here where you just do the same thing over and over again.
591.64,598.64,"And so that leads me to say, well, what if we didn't have to do all this work all over again, right?"
598.64,606.64,"If only there was some sort of data structure that we could use to keep track of things as we calculate them, right?"
606.64,610.64,To basically map one thing to another.
610.64,615.64,"So if we already calculated Fib 4 to be some value, why don't we just look it up?"
615.64,626.64,"So anytime we use things like keeping track of and looking things up, that should ring a little bell that says dictionaries can help us do that."
626.64,641.64,"And so what we can do is actually write a more efficient Fibonacci recursive Fibonacci function that uses, it's still recursive, but it uses dictionaries to keep track of values as we calculate them."
641.64,648.64,"Okay, and so this is the Fibonacci efficient function, so my name is Fib efficient."
648.64,655.64,"Notice we're still calculating Fibonacci of some n, but we're going to pass in another parameter, a dictionary."
655.64,661.64,And this dictionary will keep track of the Fibonacci values as we calculate them.
661.64,666.64,"So the key will be the n, and the value will be Fib of that n."
666.64,678.64,"And so down here you can see we're going to initialize a dictionary that has Fib of 1 maps to 1 and Fib of 2 maps to 1, right? Those are our base cases."
678.64,684.64,So let's take a look at our Fibonacci recursive function now that uses dictionaries.
684.64,690.64,No longer do we need to think about the base cases as Fibonacci of 1 is this and Fibonacci of 2 is this.
690.64,695.64,"Now all we need to do is say, well, let's look up the value in our dictionary."
695.64,698.64,That's what our base case will be.
698.64,703.64,"And we don't need to make a call to ourselves if the item is already in the dictionary, right?"
703.64,713.64,"We can just return the value associated with n in dictionary D if that n is already in the dictionary, right?"
713.64,718.64,So our two base cases down here will initially be in our dictionary.
718.64,722.64,"And as we figure out the values of Fibonacci, we'll add them to the dictionary."
722.64,725.64,And that's exactly what the recursive step will do.
725.64,730.64,"So else the values not in our dictionary, so unfortunately we have to calculate it, right?"
730.64,736.64,Which is fine. We'll basically do that the first time through that sort of exploring the left half of our path.
736.64,740.64,But that's pretty much the only times that we're going to calculate it.
740.64,743.64,All the other times we'll just look it up.
743.64,753.64,So this is going to be a little different than what we've seen before because I'm not right off the bat returning Fib and minus 1 plus Fib and minus 2.
753.64,759.64,"I'm actually still running the same recursive step, Fibon minus 1 plus Fib and minus 2."
759.64,764.64,But I'm saving it in a variable. And that's totally fine to do.
764.64,769.64,"And then before I actually return this value, let me add it to my dictionary."
769.64,777.64,So this is simply just saying this dictionary at this particular n for this particular function is equal to this thing that I just calculated.
777.64,782.64,Just a straight up dictionary addition adding this item to the dictionary.
782.64,787.64,"And then after I've added it to my dictionary, I can return that value."
787.64,793.64,"So still passing it back up the chain of function calls, but we'll save it first."
793.64,796.64,Everyone okay with this code?
796.64,805.64,Okay. So then this is the dictionary I mentioned where we initialize our two base cases and then we can print the function.
805.64,811.64,So let's trace through the code to see what exactly happens with these function calls now.
811.64,819.64,"So we're initializing our dictionary where we have n1, Fibonacci of 1 is 1, and n2, Fibonacci of 2 is 1, right?"
819.64,824.64,"Our base cases. Fibonacci of 6 again, we're doing the same function calls, right?"
824.64,831.64,So that means there's nothing stored for Fib 5. So we still have to explore what value it will be.
831.64,836.64,"Nothing stored for Fib 4, we're still exploring. Nothing stored for Fib 3, we're still exploring."
836.64,842.64,"We've reached a base case. So now, you know, the first thing we do is check if it's in the dictionary."
842.64,846.64,"It is, so we just return the one directly."
846.64,851.64,"Check if the other half is in the dictionary, return the one directly, and now we've got a value for Fib 3."
851.64,855.64,"Before returning it, let's store it in our dictionary."
855.64,864.64,"So I just calculated what Fib 3 was. Let's put it in. The key is 3, and Fib 3 is 2."
864.64,869.64,"So far so good, it's pretty similar to what we've done before, except that we're, you know, storing this value in the dictionary."
869.64,879.64,"So now we explore the right half of this Fib 4, right? Fib 3 plus Fib 2, it's already in the dictionary, so it immediately returns this addition."
879.64,886.64,"Now we know what Fib 4 is, so we added to our dictionary. Fib 4 is 3."
886.64,893.64,"Explore the right part of Fib 5, right? So Fib 4 plus Fib 3, do we go further now, right?"
893.64,897.64,"In the previous case, we explored 2 and 1. In this case, do we keep exploring?"
897.64,904.64,"No, exactly, because our base case says, if 3 is already in the dictionary, simply return the value associated with it."
904.64,911.64,"So, yep, there it is, right there, we added it a while ago, we just returned the 2 immediately, no need to go down this path."
911.64,919.64,"So now Fib 5 is done pretty quickly, so the right half, so that means we have the value for Fib 5, and we add it to a dictionary."
919.64,931.64,"We explore the right half of Fib 6. Remember beforehand, I said when we were not done, we don't need to explore this Fib 4 anymore, because we added it to our dictionary long ago."
931.64,938.64,So now all we need to do is look up the value associated with 4 from our dictionary.
938.64,953.64,"So, boom, there it is, and then we can just add Fib 5 and Fib 4 together and get the value for Fib 6, store it in the dictionary, and in this case it's the end, we don't need to do anything else with this value passing it back or anything like that."
953.64,965.64,"So, we're not recalculating anything else, right, we're just checking the dictionary and if need be we calculated, so it's an improvement, but how much of an improvement is it actually?"
965.64,971.64,"So, if we run this function and it's in the Python code, you can play around with it yourself."
971.64,988.64,"If you run the function that we originally wrote, Fib, the one where we don't store anything in the dictionary, if we try to calculate Fib Anachi of 34, it results in 11.5 million function calls."
988.64,999.64,"That's a lot of function calls, because even Fib 6 had Fib 3 being called twice, Fib 3 being called 3 times, Fib 4 being called twice, things like that."
999.64,1009.64,"You imagine how many times Fib 3 will be called when we are trying to calculate Fib 34, probably thousands, if not more."
1009.64,1020.64,"So, overall, the number of function calls we're making is 11.5 million with our original code, but the efficient version only makes 65."
1020.64,1039.6399999999999,"It's not like we went from 11.5 million to 2 million, right, we went from the order of millions to tens, which is really, really impressive in terms of speed, so if you try to run this program and take a couple seconds for Fib 34, but the efficient one will be instant."
1039.64,1053.64,"And all of these function calls have some overhead, right, you need to create an environment in Python and need to pass these parameters, so all of these function calls take a lot of time, whereas a dictionary look up is basically instantaneous, right."
1053.64,1068.64,"So in this particular case, we've given up some of our memory to store values, right, the dictionary is storing 34 entries, which is not much, but there are applications where you can't spare 34 entries, right, in your memory."
1068.64,1078.64,"In which case, you might, you know, spare some time to continue calculating without taking up some memory. So there's a little bit of trade-off between these two programs, right."
1078.64,1085.64,"One of them doesn't store anything but is slow, the other one stores things, but is fast."
1085.64,1100.64,"Let's look at one more example where we do Fibonacci on numerics, and this, I don't know when you'd use Fibonacci in your real life, but knowing all the possible ways you can make a score of X, it basketball is a little bit more useful."
1100.64,1114.64,"So let's think about this problem recursively. Certainly we could do it iteratively and brute force our way through all the possible combinations of scores, right, so in basketball you can make a basket that's worth 1.2 points or 3 points."
1114.64,1121.64,So you can think about all the possible combinations you can make to give you some score of X.
1121.64,1128.64,"We're going to think about this problem recursively, right, so let's start with our base cases."
1128.64,1141.64,"Base cases, we've got three of them. So if we think about a score of 1, so if X is equal to 1, so that means if we have a score of 1 in basketball, what are all the possible ways we could have made a 1?"
1141.64,1149.64,"You could just score 1 point and then that's it, right, I just did 1 plus C or just emphasize that we're just scoring 1 and nothings."
1149.64,1156.64,"If we make a basket that's worth 2 points, or if we have 2 points in basketball, what are all the possible ways we could have made 2?"
1156.64,1165.64,"Well, we could have scored a 1 and a 1, or we could have just scored 2 right off the bat, so that's 2 possible ways to make a score of 2."
1165.64,1171.64,"And similarly, to make a score of 3, what are all the possible ways? Well, we could have scored a 1 than a 1 than a 1."
1171.64,1180.64,"We could have scored a 2 and a 1, or we could have scored a 3 right off the bat, so that's 3 different ways you can make a score of 3 in basketball."
1180.64,1185.64,"Everyone with me so far, these are our base cases, okay?"
1185.64,1190.64,"Because the recursive step will be very, will blow your minds, it's so simple, okay?"
1190.64,1196.64,So the recursive step looks like this.
1196.64,1204.64,"Now, somebody give me what's a reasonable basketball score, like for our team, 87?"
1204.64,1213.64,"Okay, it's been probably 25 years since I've played pro basketball in grade 5, you guys, so I forgot what's a reasonable score."
1213.64,1223.64,"All right, so 87. So let's say now we're not dealing with our base case, we're dealing with some number that's bigger than one of these base cases."
1223.64,1229.64,"How do we think about this problem recursively? Well, there's three possibilities, right?"
1229.64,1240.64,"If I have a final score of 87, let's say that I think about the score of 86, right?"
1240.64,1249.64,"If I know all the possible ways I can make a score of 86, all I need to do is add 1 to that score, right?"
1249.64,1259.64,"It'll give me 87, right? So that's one possibility here, but that's not the only possibility, right?"
1259.64,1268.64,"Because I could have a score of 85, and if I add 2 to that 85, not 2 counts, right? Just the score."
1268.64,1275.64,"If I have an original score of 85, if I just add 2 to that score, it gives me my desired score of 87."
1275.64,1285.64,"So if I know the possible combinations to make 85, then I know that all I need to do is, you know, add a 2 to my score, and that'll give me 87."
1285.64,1296.64,"And then the last possibility is to know all the possible ways to make 84, the score of 84, because then I would just add a score."
1296.64,1305.64,"I would take that score and add a 3 to it to give me 87, right? So I'm sort of using my base cases to guide my recursive step."
1305.64,1317.64,"So the number of ways I can make a score of 87 is the sum of all the possible ways I can make 86 or 85 or 84, right?"
1317.64,1326.64,"Because if I made 86, I would just add 1 to it, if I made 85, I had 2 to it, and if I made 84, I'd add 3 to the score."
1326.64,1338.64,"So that's essentially what this recursive step is doing, right? I've got, these are all the possible ways I can make a score of 87, you know, X minus 1, right? So 87, 86."
1338.64,1351.64,"And that's just me calling my function, right? So score count X minus 1, score count X, plus all the possible ways to make a score of X minus 2, plus all the possible ways to make a score of X minus 3."
1351.64,1363.64,"So if I add all these 3 ways together, I would get all the possible ways I can make a score of X. Does that make sense?"
1363.64,1380.64,"Okay, so that's it, right? It's pretty clean code. It looks really nice. If we were to write this iteratively, it would be a mess, because we probably have a whole bunch of nested loops to try to brute force all the possible combinations of scores that we can make."
1380.64,1401.64,"And it wouldn't look very, very nice, very ironic. So let's do a trace of this code, just to, you know, to bring it all together. The trace will be very similar to the Fibonacci trace, except that now we have three paths to explore before having a return value, right?"
1401.64,1412.64,"So for a score of 6, I would explore how can I make a score of 5? And of course, I will explore how can I make a score of 4 and 3, but I'm not there yet, right?"
1412.64,1421.64,"First, I need to explore how to make a score of 5, which is a function call. This one will explore how to make a score of 4, and of course a 3 and a 2, but not just yet."
1421.64,1432.64,"A score of 4 will lead us to our base cases. It's just how to make a score of 3 and a 2 and a 1. These are base cases. They immediately return, and we know how to make a score of 4."
1432.64,1439.64,"A score of 3 is also a base case, and a score of 2 is also a base case, so these ones will immediately return to give us the score of 5."
1439.64,1446.64,"So now we know how to make a score of 5. We need to follow through how to make a score of 4, which is just 3 and 2 and 1."
1446.64,1460.64,"Oops, I should have changed that to be a 1 and then how to make a score of 3, and that's just a base case. So very similar trace as the Fibonacci code."
1460.64,1470.64,All right. Questions about those examples? Are they okay? Do they make sense?
1470.64,1491.64,"So there is one exercise in the Python file. It's for at home. I would like you to try to memoize this code. Memorize means basically try to use a memo, a dictionary, to store values as you calculate them, because you see that it's going to be just as inefficient as the Fibonacci code."
1491.64,1497.64,"So here we're calculating score of 4 again, where we had calculated it way back here."
1497.64,1506.64,And so try your hand at adding a dictionary to this code to try to speed it up.
1506.64,1519.64,"Okay, so the next, the second half of this lecture, we're now going to move away from recursion on numbers and sort of having these nice mathematical operations that we can just translate to code."
1519.64,1536.64,"Easily and start looking at recursion on numerical things. And we're just going to look at lists. But again, as I said, you can apply these very similar codes to any sequences of values, tuples or strings or things like that."
1536.64,1552.64,So the reason why we're looking at lists is because lists are naturally recursive. So one of the motivations I gave at the end of last lecture is that we have lists that can have elements that are other lists that can have elements that are other lists that can have elements as other lists.
1552.64,1561.64,"So without knowing sort of how deep these lists within lists go, it's going to be really hard to write iterative code."
1561.64,1581.64,"It's possible, but it's going to be really hard. And instead, we're going to see that the recursive version of this code is going to be a lot more intuitive in the long run. Maybe not, you know, maybe not right off the bat, but definitely it's a lot easier to write and to read."
1581.64,1592.64,"So let's think about lists in a recursive way. So if we were doing iteratively, what we'd say is we're going to loop through each element and do something."
1592.64,1610.64,"The problem we're going to solve is figuring out the sum of all the elements in the list to begin with. So iteratively, we just said, right, we loop over each element in the list and keep it in our result. So I've got these state variables I talked about last time, right, result and e that keep track of which element we're at and what the value is."
1610.64,1622.64,"Recursively, remember, we're going to make all these function calls until we get to a base case at which point we're going to start to build up our result."
1622.64,1635.64,"So how can we think about this list recursively? Well, let's say that we have a list and we want to find the sum of all these elements. That's our original problem."
1636.64,1649.64,"Now, let's say that we take the first element and we just extract it out, right? We know we have this list with a bunch of elements. Let's take the first one. We know it's a 10."
1649.64,1678.64,"And then let's consider the remaining elements. So the 20 onward, if I take my 10 and I know the answer to the sum of all the elements in 20 onward, right, then all I need to do to figure out the sum of my original list, right, this one here is to say it's the 10 plus the sum of whatever the sum of the 20 onward is."
1680.64,1695.64,"Now, the sum for elements 20 onward is the same problem again, right? It's the problem of finding the sum of all the elements in a list. It just so happens that our list is now our original list without that first element in it."
1696.64,1706.64,"Does everyone understand that? We've got our original problem and we've just made the same problem again, just a slightly different version of it, all the list except for that first element."
1706.64,1718.64,"So now we do the same thing, right? Let's say this is our new list, we extract the first element from it and we consider the elements except for that first one as a new list."
1719.64,1728.64,"And again, if I knew what the sum of 30 all the way on to 60 was, all I need to do is add it to the 20 that I extracted and I would know the sum of this list."
1729.64,1745.64,"So we keep doing that, right? We take our list, extract the 30 and consider the remaining elements as a list, same deal, if I knew what 40 plus 50 plus 60 was, right? The sum of all the elements in this list, I just added to the 30 and I have the answer to that problem."
1746.64,1754.64,"And we keep doing this, extracting an element and considering the remaining lists all the way down to when we have a list with just one element in it."
1755.64,1764.64,"Well, this is a pretty simple problem to solve. If I have a list with one element in it, the sum of the elements within that list is just the value of that element, right? It's just 60."
1765.64,1773.64,"So a very simple problem, no need to keep sort of going further dividing this problem into smaller pieces, I already know the answer to this one, it's very simple."
1774.64,1782.64,So this is our base case and we know the sum of the elements in a list with length 1 is that element.
1783.64,1798.64,"So once we reach the base case, we build back up our result, right? We take the 60 and we had extracted the 50 originally, so we're going to pass the sum back up to whoever called it, which was the function that extracted the 50."
1799.64,1810.64,"So now the 50 plus the 60 is 110. Now this 110 gets passed back up the chain. When we extracted the 40, we said what I'm going to add the 40 to the sum of the 50 and the 60, 110, which is 150."
1811.64,1819.64,"Pass that answer back up the chain. When I extracted the 30, I said I was just going to add the 30 with the sum of the remaining things, which I figured out is 150."
1820.64,1835.64,"The 20, right? I'd extracted it, becomes 20 plus the sum of everybody else, which is 180. So the sum is 200 and then finally my original question was to extract the 10, add it to everything else, which is the 200 that we figured out. So the full sum is 210."
1836.64,1845.64,"Does that make sense? This animation. So we've got the division, all the way down to the base case and building back up the result."
1846.64,1856.64,So let's try to write it. So we're going to write it in pieces. So the function is called total recur. It takes in a list L. We're going to recursively figure out the sum of all the elements in this list.
1857.64,1867.64,"So we can have a base case when the list is empty. We can return 0 up to you. Another base case, which is the one that I illustrated on the previous slide, is when the length of the list is 1."
1869.64,1875.64,"So when the length of the list is 1, what's the sum going to be? No need for recursion. It's just that element."
1876.64,1884.64,"And so in these slides what I've also included, in addition to the code, is an a little example. So it helps you think about what the function returns."
1884.64,1895.64,"So in this base case, when the length of the list is 1, the list would look something like this. And all I need to do is return L at index 0. So the 50. And that's my sum."
1895.64,1899.64,"And that's what I'm doing here, returning L at index 0."
1900.64,1911.64,"Now the recursive step. Remember, in the recursive step, I extracted the first element. And I said, let me save this first element. So here it is being saved as L at index 0."
1911.64,1922.64,"And I'm going to add it to something, right? So in this example here, I've got this list that's longer than 1. I'm extracting the 30, and I'm going to add it to something."
1923.64,1937.64,"Well, that's something, based on the previous slide, where I did the animation, is going to be us putting our trust in the fact that we write this function correctly."
1937.64,1944.64,That something is going to be us figuring out what the sum is of 40 and 50.
1945.64,1953.64,"It's the same problem we're trying to solve right now, the sum of 30, 40, 50, except that now I'm just going to take the sum of just the 40 and the 50."
1953.64,1965.64,"So that's something, becomes the same function we're writing right now, total recur. Except that I'm not calling it on L, not the whole thing all over again, that would be bad."
1965.64,1972.64,"But I'm going to call it on L from index 1 onwards, so essentially removing that first element."
1973.64,1978.64,Is everyone OK with that?
1978.64,1987.64,"So that's it. That's the function. Nothing else to write, right? No loop. We've basically written a function, assuming that we wrote the function correctly, right?"
1987.64,2001.64,"Which is a very strange way to think about recursion, but that's essentially what it is. You're trusting yourself to write this function correctly, such that your recursive step leads you to the base case, so that you can build back up the result correctly."
2002.64,2010.64,"So there's a lot of trust involved in writing these functions, recursive."
2010.64,2019.64,"OK, so I'm not going to go through the Python tutor, but you should definitely go through it on your own, as a practice for the quiz, things like that."
2019.64,2025.64,Let's have you write this then. So it's going to be a slight modification to the code we just wrote.
2025.64,2038.64,"So it's going to take in a list as its parameter, and instead of summing the elements in the list, like we did 10 plus 20 plus 30, whatever, I would like you to sum the lengths of the elements in the list, right?"
2038.64,2046.64,"So if I pass it in this function, it's going to sum the length of this 2 plus the length of this 1 plus the length of this 5, 2 plus 1 plus 5."
2047.64,2057.6400000000003,"So it'll be a very slight modification to the code that we just looked at. And here it is online, 70-ish. So think about the base case, right?"
2057.6400000000003,2068.6400000000003,"If you have a list with one element in it, what do you return? And if you have a list with many elements, how can you put your trust in something that you just wrote to help you get to the answer?"
2069.64,2085.64,"All right, what do you guys have for me? So let's start with the base case. And if you're having trouble, I encourage you to just in a little comment, just write down sort of what that base case looks like, right? Like I did in the slides. It looks like this, right?"
2085.64,2092.64,So what would I return if I have a list with one element in it? Yeah.
2093.64,2101.64,"Yeah, exactly. So we would turn the length of that element, right? So the length of whatever this is, a, b, whatever. Awesome."
2101.64,2107.64,How do we do the recursive step? Yeah.
2108.64,2116.64,"Yes, exactly. Total."
2116.64,2121.64,Land recur with what list?
2121.64,2130.64,"Yep, so we're going to extract that first one. So this will give us some of the links of everybody else."
2130.64,2135.64,Exactly. So we also need to add it to.
2136.64,2147.64,"Yeah, I'll see here, right? So it's fine to do it even before or after, because we're just summing these two values. So it doesn't matter if you're, you know, the order that you're summing them."
2147.64,2153.64,So that that's perfect. Any questions about this code?
2153.64,2156.64,Yes.
2156.64,2185.64,"So in terms of efficiency, recurge, this, this function will be slightly less efficient, I would say. Yeah, because it, there's a little overhead in actually making a function call."
2186.64,2194.64,"Whereas if you use a built-in operator, it's been optimized to work pretty fast."
2194.64,2197.64,Yeah.
2197.64,2202.64,"No. And when it's doing plus equals, it's definitely not doing this in the background exactly. Yeah."
2202.64,2214.64,"But this is just, I mean, we're, I'm trying to show you recursion on something that, you know, you wouldn't typically use recursion on just to help illustrate the idea of recursion."
2214.64,2223.64,"Certainly, you can use an iterative algorithm, obviously, to calculate the sum of these, these elements, and it's more intuitive, more in line with what we've been learning so far."
2223.64,2231.64,Yeah. Okay. Excellent.
2231.64,2244.64,"So now let's look at a slightly different problem. So instead of finding the sum of all the elements in a list, let's tackle the problem of looking for an element in a list."
2244.64,2248.64,"Completely different, but we're still doing some sort of list operations."
2249.64,2254.64,"We're going to start with an implementation that's not quite right, and we'll see why in a little bit."
2254.64,2258.64,So let's follow the same sort of pattern that we've seen in the previous one.
2258.64,2262.64,So let's consider a list of length one.
2262.64,2269.64,"In this particular case, if I have a list with only one element in it, how do I know if that element is the one I'm looking for?"
2269.64,2277.64,"Well, I'm just going to return this Boolean, right, whether L at index zero, that element is the one I'm looking for, the E."
2277.64,2292.64,"So notice this in list is passing in a list, the list itself, and the element I'm looking for."
2292.64,2296.64,So then let's look at the recursive step.
2296.64,2301.64,"The recursive step, in this particular case, let's say it says, well, else, right?"
2302.64,2309.64,"We might think to say, well, if it's not the one I'm looking for, then let's look in the remainder of the list."
2309.64,2318.64,"So like we did in the previous case, let's apply the same function we're writing right now to all the elements except for the first one."
2318.64,2325.64,And we're still looking for element E in those remaining elements.
2325.64,2332.64,"So we can test it out, and if we actually run it, again, please I encourage you to do Python tutor on your own, but we can test it out."
2332.64,2340.64,"And say, if, when this particular case, 2581, if I actually run this code, it will give me true."
2340.64,2348.64,"So it found the one inside the list 2581, which is good, right, it's exactly what we wanted."
2348.64,2361.64,"But if I change my input list slightly, right, and I've got 258, the element I'm looking for is here, the code will actually give me false, the one that I just wrote, which is not okay, right?"
2361.64,2365.64,I see the one is right over there.
2365.64,2368.64,And so what exactly is going on?
2368.64,2373.64,So we can run the code here.
2373.64,2376.64,So this is this code here.
2376.64,2385.64,"If you see that it gives you the incorrect value, one thing you could do when you're doing recursion is to put a print statement within the function itself, right?"
2385.64,2392.64,"So we can print maybe the list we're currently at, and the element we're looking for, and see exactly what's going on."
2392.64,2403.64,"So if I run it, it will say, well, first time through the function call, I'm looking for the number one in this list, the next time I'm looking for the one in this list,"
2403.64,2413.64,"and the last time, for my function call, I'm looking for the one in this list, right?"
2413.64,2426.64,"And already we see something went wrong, because as I was looking through these lists, right, I'm basically skipping over important elements, right?"
2426.64,2434.64,"But what this code is actually doing is only checking if the last element is the one you're looking for, right?"
2434.64,2439.64,"Because it basically ignores that first element in the code, right?"
2439.64,2447.64,"The code here, yes, it extracts that first element, but it doesn't do anything with it."
2447.64,2450.64,"So that's our problem, okay?"
2450.64,2456.64,"What we want to do is still look at further elements in the list, so that part of the code is correct."
2456.64,2468.64,"But we only want to do it in a certain situation, and that situation is when the element that we just extracted, L at index zero, is not the one we're looking for, right?"
2468.64,2477.64,So we still want to extract the first element if we have a list with more than one element in it.
2477.64,2486.64,"But as we've extracted it, check if it's the one we're looking for, if it is returned true, no need to keep searching the rest of the elements in the list."
2486.64,2495.64,"If it's not the one we're looking for, this else here, then we can look at the remaining elements in the list, and run the exact same function we're writing, right?"
2495.64,2499.64,To check if the elements is in the remaining list.
2499.64,2504.64,Does this code make sense? Is it all right?
2504.64,2515.64,"So the way I wrote this code is sort of how I personally think about the problem, and if we run the code again, it'll give me the correct answers each time."
2515.64,2524.64,"So I wanted to mention that we can actually clean up the code a little bit, and write it a little bit more pathetically."
2524.64,2528.64,"So it's a little bit nicer to read, it's more cleaned up."
2528.64,2542.64,But one of the things that was confusing for me when I first started learning recursion is that I would always see these beautiful cleaned up versions of code that do the recursion.
2542.64,2549.64,"Not sort of how we approach thinking about the problem, right? I can't come up with this nice form right off the bat."
2549.64,2555.64,"And this is one example, but there are certainly other examples of more complicated code where you see it, and it looks beautiful."
2555.64,2562.64,"And yes, if I look at it, I can figure it out, and I say, okay, yeah, that makes sense, but I personally could never come up with it on my own."
2562.64,2578.64,"So I was writing these lectures, I thought, well, how do I actually think about the problem? So I just went back one slide, and the way I think about the problem is to kind of separate it into these smaller, a bunch of different base cases, right, or a bunch of different cases."
2578.64,2582.64,And so that's what I've been trying to do in this particular lecture to help you guys understand recursion.
2582.64,2593.64,"It's, you know, think about the case when we have a list with one element in it, right? How would you solve that problem? And then think about the case when you have a list with many elements in it. How would you solve that problem?"
2593.64,2605.64,"Yes, it's true. There are some pieces here that are repeating, right? So we've got L at 0 equal E is in a couple places, but you can do that clean up later, right?"
2605.64,2619.64,"So here I've got two test cases that return, two cases that return L at 0, so we can pop them into the same test case here, and then we can check if the length of the list is 0, we can add that test case, and else we check the remainder of the list, right?"
2619.64,2632.64,"That's totally fine. And if it helps you think about the problem this way, that's okay too. But personally for me, it was a lot easier to think about the problem in terms of a list with one element in it, and then a list with many elements in it."
2632.64,2640.64,"So it's totally fine to write, you know, a little bit quote unquote inefficient looking code to begin with."
2640.64,2650.64,"Certainly don't hard code all the base cases, right? If length is 0, do this, if length is 1, do this, if length is 2, do this, right? But some reasonable base cases are okay to do."
2650.64,2667.64,"So this is just showing the simplified code. One thing that I wanted to mention, and hopefully you've noticed this already, is the function that you're writing, all of the return returns from this function need to have the same type."
2667.64,2677.64,"When we wrote, I'll go back a couple slides, when we wrote the function that calculated the sum of all the elements in a list, so that's this one here."
2677.64,2687.64,"What were we returning? Here we were returning an actual number, and then here we were assuming that this function returned an actual number that we can add to this actual number."
2688.64,2711.64,"So every single return statement needs to return the same type of object, because if you don't, if you're assuming that the base case returns a list, but then at some point in the code you're going to be working with a number or a Boolean, then Python as soon as it gets that base case is going to say, hey, you're trying to add a Boolean to a list, what's up?"
2711.64,2726.64,"So in the summing of the list elements, all the test cases returned a number, and in this case where we are trying to return, whether the element is in the list or not, notice every single one of my returns is going to return a Boolean."
2726.64,2735.64,"So here, Boolean, here, Boolean, and here in the recursive step, I'm assuming that I'm just passing this Boolean back up the chain of command."
2735.64,2751.64,"So very, very important thing. Again, something that was not made clear to me when I first started recursion, but once I knew this, it just made so much more sense, and it helped me write my code better, more perfectly right off the bat."
2751.64,2762.64,"Let's look at a slightly different example now, so we've looked at taking the sum of all the elements in the list, we've looked at frigging out whether an element is in the list, let's do something completely different."
2762.64,2777.64,"Still working with lists, let's say that we now have an input list that looks like this. So we've got a list, this is my list, beginning an end, and this list only has list elements within it."
2777.64,2787.64,"So no integers, but it's elements are lists, so here's one list element, here's another list element, and here's another list element."
2787.64,2809.64,"So in this example, I've got a list with three list elements. What I'd like to do is to flatten this list, which means that I want to remove any semblance of sub lists, and take just all the elements of the sub lists, and put them top level."
2809.64,2813.64,Does this task make sense?
2813.64,2824.64,"So I'm not assuming I've got lists within lists, I'm just assuming I've got lists with list elements that have integers or whatever."
2824.64,2834.64,"Okay, so again, let's think about the base case, let's think about the case when we have a list with one element in it, and then we can figure out the recursive step."
2834.64,2846.64,"So if I have a list with one element in it, again, I've got an example here on the right hand side, it's a list with one list element in it, that's why I've got the double square brackets."
2846.64,2862.64,"If I wanted to flatten this, what could I do? I could just grab the element at index zero, because the element at index zero is this inner list, and it is a flattened version of my list."
2863.64,2872.64,"Okay, else, what am I going to do? Well, let's do the same pattern, it seems to have worked so far for us."
2872.64,2887.64,"Let's do the pattern of extracting that first element, so grab element at index zero, so here we would grab something like square brackets 1,2, and concatenate it with something."
2887.64,2897.64,"Okay, remember, when we concatenate a list with another list, it gives us a big list with all the elements in it, exactly what we're looking for, right, when we want to flatten a list."
2897.64,2908.64,So the something we're going to add this L at index zero with is just us flattening the remainder of our list.
2908.64,2912.64,"Again, same pattern we've been seeing already, right?"
2912.64,2927.64,"So if I extract, in this example here, the 1,2 as a list, I'm going to concatenate it with the assumption that the function I'm writing will work correctly to flatten 3,4 and 9,8,7."
2927.64,2933.64,"If I flatten that, this will give me just a list with 3,4,9,8,7 in it."
2933.64,2939.64,"Okay, and if I concatenate 1,2 with 3,4,9,8,7, that just gives me 3,4,9,8,7."
2941.64,2946.64,"Everyone with me, is that all right? Okay, good, I see some nods, so that's actually pretty good sign."
2946.64,2954.64,"Okay, you are with me, right? Because now it is your turn."
2954.64,2961.64,So we're going to write a variation of whether an element is in a list.
2961.64,2965.64,So I'm going to give you a very similar scenario to this flatten one.
2965.64,2969.64,So I'm going to give you a list that contains list elements.
2969.64,2973.64,"So here's my list, that contains list elements in it."
2973.64,2979.64,"And what I'd like you to do is write a recursive function that checks whether this element,"
2979.64,2986.64,"whatever the second parameter of the function in my function call, is in these list elements."
2986.64,2992.64,"So not at the top level, like we wrote last, the last code to check if an element is in the list, right?"
2992.64,3003.64,"But in these sub lists, right? So just to show you kind of the difference, if I check whether 3 is in 1,2,3, that will be true."
3003.64,3010.64,"But if I check whether 3 is in, you know, the list containing the list 1,2,3, that's false,"
3010.64,3014.64,"because it's checking whether the 3 is equal to this list, right?"
3014.64,3020.64,It's just doing a top level equality here.
3020.64,3028.64,So let's have you write this code down online 166.
3028.64,3034.64,"You may use the in operator, right, to check if an element is in a list itself,"
3034.64,3040.64,"but obviously you won't be able to use the in operator, nor should you, because then we're not writing a recursive function,"
3040.64,3045.64,"to check if the element is within a list element, right?"
3045.64,3053.64,So have you worked on it for a couple minutes and then we can write it together.
3053.64,3058.64,"All right, does anyone have a start? So let's look at the case where we have 1 element in it."
3058.64,3068.64,How do you check whether that element is within the list inside?
3068.64,3072.64,"So if, right, this is our case with 1 element in it."
3072.64,3082.64,The length of L equals 1.
3082.64,3091.64,Yeah.
3091.64,3092.64,"Yeah, exactly."
3092.64,3098.64,"E and L is the correct thing to do, L at index 0, right?"
3098.64,3103.64,"So if this is our L, that's why I added this little example here, so it can help us."
3103.64,3110.64,"So L at index 0 is this guy here, and all I need to do is check if E is in L at index 0, right?"
3110.64,3117.64,And I can just return that right off the bat.
3117.64,3124.64,"I could do if E in L 0 return true, L's return false, but E in L 0 is already a Boolean,"
3124.64,3128.64,so I can just return that directly.
3128.64,3136.64,"Okay, L's, we have a list with more than one element in it, right?"
3136.64,3139.64,So what do we do here?
3139.64,3146.64,"Remember, extract the first element, and then do the rest."
3146.64,3154.64,"So let's say this, let's say the first element is L at index 0, right?"
3154.64,3159.64,That'll help us think about it a little bit.
3159.64,3164.64,"So before looking at the remainder of the list and calling our recursive function,"
3164.64,3169.64,what did we do when we checked if an element was in the list when we just had a plain list?
3169.64,3186.64,"We just said if E is in first, return true, L's return false, right?"
3186.64,3192.64,But we don't want to do L's return false because that's not quite true.
3192.64,3199.64,"L's, we want to look at the remainder of the list, right?"
3199.64,3206.64,"We want to see if the element, obviously, if the element is not in the first thing that I just extracted, right?"
3206.64,3215.64,"This list here, then I would like to say is it in the rest of this list, right?"
3215.64,3219.64,Which is us calling the function that we're just writing all over again.
3219.64,3240.64,"So we can return the name of this function in lists of lists, and then L from one onward with the same element we're trying to find."
3240.64,3244.64,"And of course, we can simplify this just like we could simplify the previous one,"
3244.64,3257.64,"but it helps to think about it in these two cases, a list with one element and a list with many elements."
3257.64,3269.64,Any questions about this? Yes.
3269.64,3276.64,This one? This one we're considering a list with one list inside it.
3276.64,3285.64,"Yeah. We could include another base case, I suppose, if the length of L is zero return false, that would also work."
3285.64,3290.64,"Because obviously if the list is empty, it's not in there."
3290.64,3294.64,"Okay, so when do we use recursion? Obviously, a lot of the examples we've seen here,"
3294.64,3298.64,"they're very intuitive to write iteratively, right?"
3298.64,3305.64,"But I mentioned a couple of examples last time, where it's more intuitive to use recursion."
3305.64,3312.64,"And specifically, I wanted to draw a little bit of a parallel to this thing when we learned about while loops, right?"
3312.64,3317.64,"We said, well, what if we tried to code a little game that just used if and else's?"
3317.64,3323.64,"I said that we would have a bunch of nested if-else statements, right, without a while loop."
3323.64,3329.64,Because we don't know how deep to make these if-else statements.
3329.64,3335.64,And so a very similar idea exists with recursion and when to use recursion.
3335.64,3342.64,"So if I had a list with a whole bunch of lists in it, and those lists could have lists within it, and so on and so on,"
3342.64,3347.64,"I don't know how deep I need to make my code go, right?"
3347.64,3352.64,"So an example using a for loop would be to say for each element in L, right?"
3352.64,3358.64,"I'm going to say I'm going to look at each element. I'm going to say, well, if you're not a list, then I can deal with you directly."
3358.64,3362.64,"But if you are a list, then I need to iterate over you."
3362.64,3368.64,"And so I've got this other iteration here for each j and i, right, from one of those lists."
3368.64,3372.64,"Again, I would say, are you a list? If not, I'll deal with you directly."
3372.64,3376.64,"Else, you are a list, so I do need to iterate over you."
3376.64,3379.64,And you can see this nested idea that comes into play here.
3379.64,3388.64,"And of course, we could try to use a while loop to optimize the code a little bit, say, you know, while this element type is not a list, do this, you know, things like that."
3388.64,3393.64,But it leads to some relief verbose code.
3393.64,3398.64,And so recursion is a way for us to deal with these lists within lists within lists.
3398.64,3402.64,"And of course, when you have data structures that you don't know how long or how deep they go."
3402.64,3408.64,So I mentioned file systems and a set of operations last lecture has really nice places to use recursion.
3408.64,3417.64,"Scooby Doo gang looking for, you know, their culprit rooms that have doors that lead to other rooms that have doors that lead to other rooms."
3417.64,3421.64,They don't know how many doors they need to go through to get to a room without doors.
3421.64,3428.64,"Obviously recursion, they should use, and then a bunch of other fun examples of places to use recursion."
3428.64,3441.64,"So the last bit of class, I would like to work through this example where we're going to see the code to solve lists within lists within lists within lists."
3441.64,3449.64,"But before we do that, we're going to talk about, so we're going to do that example in the context of reversing a list."
3449.64,3456.64,"Before we look at a list that has all these different sub lists within it, let's look at a list that has just integers."
3456.64,3463.64,How would we think about this problem recursively to reverse all the elements in this list?
3463.64,3470.64,"So again, we're going to use the very same pattern we've been using all throughout today when we've been dealing with lists."
3470.64,3477.64,"We're going to take out the first element, extract it, and we're going to deal with the remainder of the list."
3477.64,3482.64,"Basically, by running the same function, we're writing on the remainder of the list."
3482.64,3488.64,"So let's say I have my original list, and I look at my first element, just like before, I'm going to extract it out."
3488.64,3501.64,"If I take this first element, and I pop it at the end, and then I consider the remainder list, everything except for that first element that I put at the end,"
3501.64,3508.64,I can just call the same function I'm writing right now to reverse the remaining list.
3508.64,3517.64,"Which means that I'm going to take this remaining list, grab the first element, pop it at the end, and deal with the remaining list."
3517.64,3524.64,"Again, take the first element, pop it at the end, deal with the remaining list, until I have a list with length 1."
3524.64,3530.64,"How do I ever reverse a list that only has one element in it? It's just that list, right?"
3530.64,3537.64,"I just, you know, reversing a list L is just L, right? Okay, good."
3537.64,3540.64,So that's the idea.
3540.64,3549.64,"And notice that when we're building back up the result, we took that first element, and we tacked it onto the end."
3550.64,3559.64,"So we're going to do another list concatenation kind of deal, except that the thing that I'm concatenating now, the first element, will be at the end, right?"
3559.64,3565.64,It'll be the second part of my plus. So I'm just giving you a heads up. That's what it would look like.
3565.64,3577.64,"So let's write the code. If the length of the list is 1, right? If I'm reversing a list with one element in it, just return that list. Easy peasy, right? It's just the list itself."
3577.64,3590.64,"Okay, L's, and this is where the fun comes in, right? I've got something, so I'm going to do something concatenated with something else."
3590.64,3598.64,"So I'm extracting the first element. There it is, L at index 0, but it's sitting somewhere funny that we haven't seen it sit before."
3598.64,3609.64,"It's sitting on the second to the right of the concatenation, and that's fine because what we want to do is take the element from the first, the beginning of the list, and tack it onto the end."
3609.64,3616.64,And there's something else that's funny about it. I've put it in square brackets.
3616.64,3623.64,"Now, again, I'm including this example to help us think about it. Why are those square brackets there?"
3623.64,3633.64,"Think about what we want this function to return. Is it returning a number? No, is it returning a Boolean? No, it's returning a list, right?"
3633.64,3641.64,"This function I want to take in a list and give me back a list, but where my elements are in reverse order."
3641.64,3650.64,"So what I want to do, right, you can already see this return over here, is returning a list, right, so it'll be square brackets 10 or whatever."
3650.64,3665.64,"In my recursive step, if I'm concatenating, I want to concatenate this thing here, which I'll tell you about in the next slide, but I'm going to concatenate it with, it's going to be a list with some other list, right?"
3665.64,3676.64,"If I concatenate a list with a number, that L at 0 is, L at 0 is a 10, right? So if I concatenate a list with a number, Python will yell at me."
3676.64,3689.64,"So what I need to do is make that number that I just extracted L at 0 be a list, so I'm just going to slap a square bracket around it and say, hey, Python, this is a list with one element in it."
3689.64,3692.64,Does that make sense? Cool.
3692.64,3710.64,"So then what that means is, I've got this 10 that I extracted, I'm going to concatenate something with that 10, and that something is me putting my trust into the function I'm writing to say that something is going to be the 20, 30, 40, successfully reversed, right, 40, 30, 20."
3710.64,3715.64,"If I can do that, 40, 30, 20, and I concatenate it with a 10, my job is done."
3715.64,3720.64,"I have successfully reversed 10, 20, 30, 40, to be 40, 30, 20, 10."
3720.64,3733.64,"And so let's just do that. That's me putting my trust in this function I'm writing. I'm calling the same function again saying, hey, I would like to reverse the remainder of the list."
3733.64,3742.64,"Exactly as we have been in the past, right? Super weird to think about still because we're trusting something that we're writing."
3742.64,3756.64,"So then let's test it out. Let's run it. So if I run it with list one, two, ABC, Python will reverse my list, right? So it will print ABC, then the two, then the one."
3756.64,3767.64,Let's say I run it now with something slightly different. So I run it with this list here. How many elements does this list have test?
3768.64,3775.64,"Three, exactly. The first one is an integer, the second one is a list, and the last one is a list that's got a bunch of garbage in it."
3775.64,3780.64,"But as test, I don't care because I just care that I have three elements inside."
3780.64,3788.64,"And so when I run this function on test, it will reverse just the top level because that's what this is doing, right?"
3788.64,3800.64,"And nowhere in here, did I say I want to reverse lists within lists, right? I didn't say if you're a list also reverse yourself, I just said top level, take this element, put it at the end."
3800.64,3809.64,"So when I reverse test, this funky looking test over here, it will take that first element, put it at the end, the middle element stays where it is."
3809.64,3823.64,"And the last element comes first, is everyone okay so far? I'm worried there aren't many more questions, so okay."
3823.64,3832.64,"All right, so that's good, but this is now not really what I'd like, right?"
3832.64,3846.64,"So what I'd like is if I have lists within lists within lists, and those lists have some sort of elements within them, right? At the lowest level, I've got a list that's going to have some integer string or whatever in it."
3846.64,3861.64,"What I would like to do is to reverse those elements as well. So really what I would have liked to have, if I passed in this list here, is to say why don't you reverse everything?"
3861.64,3869.64,So I would like to have had gf as a list and then the e and then the d and then the one.
3869.64,3887.64,"And so this is where we're going to do that. So let's say I now have a list, so each one of these blue squares is my list elements and my top level, and they happen to have some sort of lists within them."
3887.64,3900.64,"How do I do this? Well, now that I have potential list elements, I need to have my recursive function test whether the element I'm currently considering is a list or not."
3900.64,3908.64,"If it's not like the three and the four, I can treat them in the exact same way that we treated them in this case."
3908.64,3921.64,"But if it is a list as this one is, right, this is a list element, and this is also a list element that has lists elements within it, so that's even funkier, then we need to consider them separately."
3921.64,3934.64,"So let's take the code that we wrote in the previous slide, because it's a good start, extract the first element, right, put it at the end. That's what we did before."
3934.64,3945.64,"But before leaving, let's say if you are a list, right, if you are a list, then also reverse yourself."
3945.64,3953.64,"So not only do I want top level, that list, you know, that element to go to the end, I also want to consider what you are."
3953.64,3958.64,"I don't want this last element to be one comma two, I want to reverse its elements two to be two comma one."
3958.64,3964.64,"So in the end, what I want this to give me is eight, seven, six, five, four, three, two, one."
3964.64,3969.64,"All right, so that deals with that first element being popped at the end there."
3969.64,3974.64,"Now I consider my new list, and again, this is going to be the recursive step."
3974.64,3982.64,"The element at the front, again, I extract it, it's just a number, right, nothing special here, so you just go to the end."
3982.64,3987.64,"Right, just like before. Nothing to consider, nothing to reverse for that three."
3987.64,3992.64,"Again, the four, just like before, it goes to the end."
3992.64,3996.64,"And now, what about this list with lists within it, and so on?"
3996.64,4000.64,"Well, we've reached sort of this quote-unquote base case."
4000.64,4007.64,"So there's nothing to put at the end, but you can imagine being put at the end if there were other elements within it."
4007.64,4012.64,"So this one is going to stay as is, sorry about that, this one is going to stay as is."
4012.64,4017.64,"But what we're going to do is going to say, well, you are a list, just like this one was a list, right?"
4017.64,4022.64,It was a list with two numbers in it. So you are also a list with two elements in it.
4022.64,4026.64,So the first step I would like you to do is reverse yourself.
4026.64,4032.64,"So the seven eight will come to the front, and the five six will go after it."
4033.64,4038.64,But its elements also are lists.
4038.64,4045.64,"So not only do I want to reverse you, but I want you to tell all your elements to reverse themselves."
4045.64,4055.64,"So the five six should reverse to be a comma six five, and the seven eight should reverse itself to become a eight seven."
4055.64,4057.64,Okay.
4058.64,4063.64,"Does that make sense? Conceptually, I think we got it."
4063.64,4071.64,So we want to reverse as far deep as we can until we get to some numbers.
4071.64,4075.64,Okay. So let's write the code.
4075.64,4079.64,"We're going to do a very similar thing to what we've done in the past, right?"
4079.64,4083.64,All of these examples following the exact same pattern.
4083.64,4090.64,"Consider a list with one element in it, and then consider a list with many elements in it."
4090.64,4097.639999999999,"If I have a list with one element in it, so here, here's a list, right?"
4097.639999999999,4101.639999999999,It's going to have only one element in it.
4101.639999999999,4109.639999999999,"If the list is a, if that element within that list is a number,"
4109.64,4116.64,"I'm going to do something different than if the element within this list is a list, right?"
4116.64,4123.64,"So what I actually want to do inside this, if LnL is equal to one, is have two subparts, right?"
4123.64,4125.64,Depending on whether it's a list or not.
4125.64,4131.64,"Because if it's just a number, I'm happy to just leave it as is, right?"
4131.64,4134.64,"Like this number is already in place, right?"
4134.64,4136.64,It's already reversed.
4136.64,4144.64,"But if the element within it is a list, right?"
4144.64,4148.64,"This element is one element inside my list, is also a list."
4148.64,4151.64,I want it to reverse itself.
4151.64,4157.64,"So if the length of the list is one, I now check the type."
4157.64,4161.64,"If it's not a list, I do exactly the same thing as I did before."
4161.64,4164.64,"If it's not a list, you are already reversed."
4164.64,4166.64,No need to reverse anything else.
4166.64,4167.64,"Yes, question."
4167.64,4172.64,I guess we'll open the piece by one element.
4172.64,4177.64,"Yes, so we're just dividing it into one element or two, or more than one."
4177.64,4184.64,"So in the case where we have one element, right, this is my list, and this is the one element."
4184.64,4190.64,"And if I have an element that's a list itself, then this is still one element."
4190.64,4191.64,Yep.
4191.64,4196.64,Let's say you raise the brackets on the outside of both of them.
4196.64,4197.64,Yep.
4197.64,4202.64,This is now a list with two elements in it.
4202.64,4204.64,"Yep, exactly."
4204.64,4210.64,"But I am considering the case where I have a list with one element, it happens to be another list."
4210.64,4213.64,"And what's inside it, I don't currently care."
4213.64,4217.64,"So if it's not a list, it's already reversed."
4217.64,4221.64,"Otherwise, what do we do?"
4221.64,4228.64,"Well, we want to ask it to reverse itself, and that's the function we're currently writing."
4228.64,4232.64,Is that cool?
4232.64,4234.64,I guess.
4234.64,4237.64,"Again, a lot of trust going on here, you guys."
4237.64,4245.64,"So we're calling deep reverse this function we are currently writing on this list element,"
4245.64,4252.64,"and a lot in dexera, right, it's our only element."
4252.64,4270.64,"And notice, again, I've got these square brackets around here because this function is supposed to return a list."
4270.64,4277.64,"So just like in the previous case where I slapped on some square brackets around the number, I have to do it here as well."
4277.64,4280.64,Everyone okay with this case?
4280.64,4284.64,Because the recursive step is going to be even crazier.
4284.64,4289.64,"Else, we have a list with more than one element in it."
4289.64,4298.64,"So we have a list with some stuff here, and then I have potentially another list and a bunch of other stuff here."
4298.64,4309.64,"So then, what I would like to do is, again, according to our pattern that we've been looking at,"
4309.64,4313.64,"is to say, I'm going to extract the first element in the list, right?"
4313.64,4319.64,"So if I have a list with many elements, let's extract the first one and deal with it."
4319.64,4330.64,"But again, I need to take care because that first element may be a number, or a string, or whatever, or it may be a list."
4330.64,4333.64,And I deal with these two cases separately.
4333.64,4344.64,"If it's just a number, so that's this if case here, so if the type of L at zero, the thing that I've extracted is a list, then what I need to do is what I had in the previous example."
4344.64,4351.64,"I grab that first element, slap square brackets around it, and concatenate it with deeper verse of the rest of it."
4351.64,4355.64,"Exactly the same as the previous case, right? Because it's just a number."
4355.64,4358.64,I do what I did before. Plop it to the end and we're done.
4358.64,4363.64,"And again, I'm making a function call here to myself."
4363.64,4372.64,"Else, okay, this thing here, this L at n take zero that I've extracted, is a list, right?"
4372.64,4385.64,"So not only do I have to call deeper verse on these guys here, but everybody together, we have to call deeper verse on the first element as well, right?"
4385.64,4391.64,Because it's a list. I can't just put it to the end. I want to reverse it to reverse all of its elements.
4391.64,4396.64,"Okay, so this is the code to do that, right?"
4396.64,4405.64,"This bit here, deeper verse L1 colon, tells the remainder of the list to reverse itself."
4405.64,4409.64,Exactly like we did in the integer case. That was the same.
4409.64,4420.64,"But we concatenate that, again, by putting square brackets around it, because we want to concatenate with the list, we concatenate that with deeper verseing our element and index here."
4420.64,4429.64,"Right, so not only do we put this at the end to reverse it, but we need to reverse all of its elements as well."
4429.64,4436.64,"Okay, there are no more lines to this code, but what are your thoughts?"
4436.64,4441.64,"I know, yeah."
4441.64,4448.64,"So, yeah, so we put square brackets because we want to maintain the same structure of what the original list was."
4448.64,4457.64,"So if it's an integer, I guess the simplest case to explain it. So if it's an integer, you can't concatenate the list with the integer, right? It'll be a problem."
4457.64,4465.64,So you want to concatenate the list with the integer inside a list as a single element.
4465.64,4479.64,"So what we can do is we can simplify the code. Again, I personally think of this as a little bit easier to think about. Just kind of as I'm extracting out the case where I have the list with one thing and the list with many things."
4479.64,4485.64,"But you can certainly think of it like this. So if I have an empty list, just return an empty list."
4485.64,4495.64,"I'm extracting the element and index zero directly, and I deeperverse that the rest of the list concatenated with that element at the end."
4495.64,4507.64,"Again, oops, noting that we are putting this element as a list. And else we can deeperverse the rest of the list concatenated with deeperversing this guy here."
4507.64,4517.64,"So not only do we put it at the end, but we also reverse all of its elements. So this is the simplified version as a simplified code."
4517.64,4528.64,"So this recursion that we saw, all these examples here that we applied to lists, can actually apply to any indexable ordered sequences, right?"
4528.64,4537.64,"Same code will work for tuples. The same code will work for strings, except for the one where, because you can't have strings within strings within strings."
4537.64,4548.64,"But certainly, you know, summing the elements in a list and checking whether an element is in a list, will work for tuples as well. And, you know, some of these will work for strings as long as you can do that operation on the strings."
4548.64,4554.64,"Because these are all indexable sequences, right? So it shouldn't be a problem."
4554.64,4572.64,"So lots of takeaways here with recursion. This last example, namely, it looks really nice in the cleaned up form. And it's, you know, like, five lines of code to solve this really kind of hard problem that you would otherwise have to solve using Y loops and four loops and things like that."
4572.64,4577.64,So I definitely encourage you to take a look through the Python tutor links that I've put in.
4577.64,4592.64,"Like two tips. So the two big takeaways on recursion is this thing about base cases, right? Any time you have a return statement and you're writing a recursive function, make sure that every single return statement is returning something that is of that same type."
4592.64,4601.64,"Otherwise, you'll have type mismatches all over the place. And then the recursive step takes advantage of the fact that you are returning these kinds of types, right?"
4601.64,4605.64,So then those operations and the recursive step will work with those types.
4605.64,4619.64,"And the second is the function doesn't have to be efficient on the first pass, right? So the way we thought about the problem by separating in a list with one element and many is easier for me to think about because I can wrap my head around the problem."
4619.64,4628.64,"And, you know, you don't have to write the most efficient code right off the bat for recursion. Certainly no need to do that. But you can definitely clean it up after you have something that works."
4628.64,4637.64,"Many practice problems on the Python file for today, many, many practice problems. Memorizing the basketball, obviously, I mentioned that."
4637.64,4650.64,"An example, a little practice with no lists within lists. An example or a practice with lists within lists within lists. And then I included three buggy recursion implementations for you to try to fix."
4650.64,4657.64,So a little bit of debugging practice plus recursive practice. All right. Thanks all.
